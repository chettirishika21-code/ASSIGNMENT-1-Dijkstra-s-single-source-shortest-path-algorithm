#include <iostream>
#include <string>
#include <algorithm>
#include <vector>

using namespace std;

// Function to perform XOR operation on two equal-length binary strings
string xor_op(string a, string b) {
    string result = "";
    // Note: Both strings must be of the same length (generator length)
    for (size_t i = 0; i < a.length(); i++) {
        if (a[i] == b[i]) {
            result += '0';
        } else {
            result += '1';
        }
    }
    return result;
}

/**
 * @brief Calculates the CRC remainder and returns it as a string.
 * @param data The original data stream (M).
 * @param generator The generator bits (G).
 * @return The CRC checksum (R).
 */
string calculateCRC(string data, string generator) {
    int data_len = data.length();
    int gen_len = generator.length();
    int k = gen_len - 1; // Degree of the generator

    // 1. Augment the data by appending k zeros
    string augmented_data = data + string(k, '0');

    // Make a mutable copy for the division process
    string dividend = augmented_data;

    // 2. Perform the Modulo-2 (XOR) Division
    // The loop iterates over the data bits (since the division process 
    // effectively shifts the generator over the original data length)
    for (int i = 0; i < data_len; i++) {
        // Only proceed if the leading bit is '1'
        if (dividend[i] == '1') {
            // Get the current segment of the dividend (must be length gen_len)
            string segment = dividend.substr(i, gen_len);
            
            // Perform XOR
            string remainder_segment = xor_op(segment, generator);

            // Replace the segment in the dividend with the result.
            // This replacement handles the "subtraction and bringing down" in division.
            // Since the leading bit of the remainder is always '0', 
            // the overall effect is a shift for the next iteration.
            dividend.replace(i, gen_len, remainder_segment);
        }
    }

    // 3. The last k bits of the final dividend is the CRC remainder (checksum)
    string remainder = dividend.substr(data_len, k); 
    
    return remainder;
}

int main() {
    // Input parameters for the problem
    string data_stream = "10011101";
    // Generator G(x) = x^3 + 1 => 1*x^3 + 0*x^2 + 0*x^1 + 1*x^0
    string generator_bits = "1001"; 

    cout << "--- CRC Codeword Calculation ---" << endl;
    cout << "Data Stream (M):       " << data_stream << endl;
    cout << "Generator (G):         " << generator_bits << " (x^3 + 1)" << endl;
    
    // Calculate the CRC remainder
    string crc_checksum = calculateCRC(data_stream, generator_bits);

    // Form the actual transmitted bit string
    string transmitted_codeword = data_stream + crc_checksum;

    cout << "---" << endl;
    cout << "Calculated Checksum (R): " << crc_checksum << endl;
    cout << "Actual Bit String Transmitted (T): " << transmitted_codeword << endl;
    
    return 0;
}

Output:

--- CRC Codeword Calculation ---
Data Stream (M):       10011101
Generator (G):         1001 (x^3 + 1)
---
Calculated Checksum (R): 100
Actual Bit String Transmitted (T): 10011101100


=== Code Execution Successful ===

